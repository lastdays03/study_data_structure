# 2ì£¼ì°¨: íŠ¸ë¦¬ êµ¬ì¡° - ì´ì§„ íŠ¸ë¦¬, BST, í™

## ğŸ¯ í•™ìŠµ ëª©í‘œ
- **ì‹¬ì¸µ ì´í•´**: ì¬ê·€ì  ì‚¬ê³ ë°©ì‹ê³¼ íŠ¸ë¦¬ êµ¬ì¡°ì˜ ìˆ˜í•™ì  ì„±ì§ˆì„ ì´í•´í•©ë‹ˆë‹¤.
- **êµ¬í˜„ ëŠ¥ë ¥**: ë³µì¡í•œ í¬ì¸í„° ì¡°ì‘ê³¼ ì¬ê·€ í˜¸ì¶œì„ ì½”ë“œë¡œ êµ¬í˜„í•©ë‹ˆë‹¤.
- **í™œìš© ëŠ¥ë ¥**: ê³„ì¸µì  ë°ì´í„° í‘œí˜„ê³¼ ìš°ì„ ìˆœìœ„ ê´€ë¦¬ì— íŠ¸ë¦¬ë¥¼ í™œìš©í•©ë‹ˆë‹¤.

## ğŸ“š í•µì‹¬ ê°œë… ì‹¬ì¸µ ë¶„ì„

### 1. íŠ¸ë¦¬ (Tree)ì™€ ì¬ê·€ (Recursion)

#### ğŸ§  ì‹¬ì¸µ ë™ì‘ ì›ë¦¬: ì‹œìŠ¤í…œ ìŠ¤íƒê³¼ íŠ¸ë¦¬ ìˆœíšŒ
- **ì¬ê·€ì˜ ë³¸ì§ˆ**: íŠ¸ë¦¬ëŠ” "ë£¨íŠ¸ ë…¸ë“œ + ì™¼ìª½ ì„œë¸Œ íŠ¸ë¦¬ + ì˜¤ë¥¸ìª½ ì„œë¸Œ íŠ¸ë¦¬"ë¡œ ì •ì˜ë˜ëŠ” ì¬ê·€ì  êµ¬ì¡°ì…ë‹ˆë‹¤. ë”°ë¼ì„œ íŠ¸ë¦¬ë¥¼ ë‹¤ë£¨ëŠ” ê°€ì¥ ìì—°ìŠ¤ëŸ¬ìš´ ë°©ë²•ì€ ì¬ê·€ì…ë‹ˆë‹¤.
- **ìŠ¤íƒ í”„ë ˆì„ (Stack Frame)**: `preorder(node.left)`ë¥¼ í˜¸ì¶œí•˜ë©´, í˜„ì¬ í•¨ìˆ˜ì˜ ìƒíƒœ(ì§€ì—­ ë³€ìˆ˜, ë¦¬í„´ ì£¼ì†Œ ë“±)ê°€ ì‹œìŠ¤í…œ ìŠ¤íƒì— ì €ì¥ë©ë‹ˆë‹¤. íŠ¸ë¦¬ì˜ ë†’ì´(Height)ë§Œí¼ ìŠ¤íƒ í”„ë ˆì„ì´ ìŒ“ì´ê²Œ ë˜ë¯€ë¡œ, íŠ¸ë¦¬ê°€ ê¹Šì–´ì§€ë©´ `Stack Overflow` ìœ„í—˜ì´ ìˆìŠµë‹ˆë‹¤.
- **ê³µê°„ ë³µì¡ë„**: ì¬ê·€ ìˆœíšŒì˜ ê³µê°„ ë³µì¡ë„ëŠ” íŠ¸ë¦¬ì˜ ë†’ì´ `O(h)`ì— ë¹„ë¡€í•©ë‹ˆë‹¤. (ìµœì•…ì˜ ê²½ìš° O(n))

### 2. ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (BST)

#### âš–ï¸ ê· í˜•(Balance)ì˜ ì¤‘ìš”ì„±
- **ì´ìƒì ì¸ ê²½ìš°**: íŠ¸ë¦¬ê°€ ê½‰ ì°¨ ìˆëŠ” ì™„ì „ ì´ì§„ íŠ¸ë¦¬ í˜•íƒœë¼ë©´ ë†’ì´ëŠ” `log n`ì…ë‹ˆë‹¤. íƒìƒ‰ ì†ë„ë„ `O(log n)`ì…ë‹ˆë‹¤.
- **ìµœì•…ì˜ ê²½ìš° (Skewed Tree)**: 1, 2, 3, 4, 5 ìˆœì„œëŒ€ë¡œ ì‚½ì…í•˜ë©´ ì˜¤ë¥¸ìª½ìœ¼ë¡œë§Œ ë»—ì€ ì¼ìí˜• íŠ¸ë¦¬ê°€ ë©ë‹ˆë‹¤. ì´ëŠ” ì‚¬ì‹¤ìƒ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì™€ ê°™ìœ¼ë©°, ë†’ì´ëŠ” `n`, íƒìƒ‰ ì†ë„ëŠ” `O(n)`ì´ ë©ë‹ˆë‹¤.
- **í•´ê²°ì±…**: ì´ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ìŠ¤ìŠ¤ë¡œ ê· í˜•ì„ ë§ì¶”ëŠ” **AVL íŠ¸ë¦¬**, **Red-Black íŠ¸ë¦¬** ë“±ì´ ì¡´ì¬í•©ë‹ˆë‹¤. (ì‹¬í™” ì£¼ì œ)

### 3. í™ (Heap)

#### ğŸ”¢ ë°°ì—´ë¡œ êµ¬í˜„í•˜ëŠ” íŠ¸ë¦¬ì˜ ë§ˆë²•
- **ì™„ì „ ì´ì§„ íŠ¸ë¦¬ ì„±ì§ˆ**: í™ì€ ë§ˆì§€ë§‰ ë ˆë²¨ì„ ì œì™¸í•˜ê³  ê½‰ ì°¨ ìˆê³ , ë§ˆì§€ë§‰ ë ˆë²¨ì€ ì™¼ìª½ë¶€í„° ì±„ì›Œì§‘ë‹ˆë‹¤. ì´ ì„±ì§ˆ ë•ë¶„ì— **ì¤‘ê°„ì— ë¹ˆ ê³µê°„ ì—†ì´ ë°°ì—´ì— ì°¨ê³¡ì°¨ê³¡ ì €ì¥**í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **ì¸ë±ìŠ¤ ê³µì‹ì˜ ìœ ë„**:
    - ë£¨íŠ¸ ë…¸ë“œ ì¸ë±ìŠ¤: `0`
    - ë¶€ëª¨ `i`ì˜ ì™¼ìª½ ìì‹: `2*i + 1`
    - ë¶€ëª¨ `i`ì˜ ì˜¤ë¥¸ìª½ ìì‹: `2*i + 2`
    - ìì‹ `j`ì˜ ë¶€ëª¨: `(j-1) // 2`
- **í™œìš©**: **ìš°ì„ ìˆœìœ„ í(Priority Queue)** êµ¬í˜„ì˜ í‘œì¤€ì…ë‹ˆë‹¤. ìš´ì˜ì²´ì œì˜ ì‘ì—… ìŠ¤ì¼€ì¤„ë§(ìš°ì„ ìˆœìœ„ ë†’ì€ ì‘ì—… ë¨¼ì € ì²˜ë¦¬), ë„¤íŠ¸ì›Œí¬ íŒ¨í‚· ì²˜ë¦¬ ë“±ì— ì“°ì…ë‹ˆë‹¤.

---

## ğŸ’» íŒŒì´ì¬ êµ¬í˜„ ê°€ì´ë“œ

### 1. ì´ì§„ íŠ¸ë¦¬ (Binary Tree) & ìˆœíšŒ
```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorder_traversal(root):
    """ì „ìœ„ ìˆœíšŒ: Root -> Left -> Right"""
    if root is None:
        return []
    return [root.val] + preorder_traversal(root.left) + preorder_traversal(root.right)

def inorder_traversal(root):
    """ì¤‘ìœ„ ìˆœíšŒ: Left -> Root -> Right"""
    # êµ¬í˜„ ê³¼ì œ
    pass

def postorder_traversal(root):
    """í›„ìœ„ ìˆœíšŒ: Left -> Right -> Root"""
    # êµ¬í˜„ ê³¼ì œ
    pass

# í…ŒìŠ¤íŠ¸
#      1
#     / \
#    2   3
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
print(preorder_traversal(root)) # [1, 2, 3]
```

### 2. ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ (BST) êµ¬í˜„
```python
class BST:
    def __init__(self):
        self.root = None

    def insert(self, val):
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert_recursive(self.root, val)

    def _insert_recursive(self, node, val):
        if val < node.val:
            if node.left:
                self._insert_recursive(node.left, val)
            else:
                node.left = TreeNode(val)
        else: # val >= node.val
            if node.right:
                self._insert_recursive(node.right, val)
            else:
                node.right = TreeNode(val)

    def search(self, val):
        # êµ¬í˜„ ê³¼ì œ: ê°’ì´ ì¡´ì¬í•˜ë©´ True, ì—†ìœ¼ë©´ False ë°˜í™˜
        # íŒíŠ¸: valê³¼ node.valì„ ë¹„êµí•˜ì—¬ ì™¼ìª½/ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™
        pass

    def delete(self, val):
        # ì‹¬í™” ê³¼ì œ: ë…¸ë“œ ì‚­ì œ êµ¬í˜„
        # Case 1: ë¦¬í”„ ë…¸ë“œ (ìì‹ 0ê°œ) -> ê·¸ëƒ¥ ì‚­ì œ
        # Case 2: ìì‹ì´ 1ê°œ -> ìì‹ì„ ë‚´ ìœ„ì¹˜ë¡œ ì˜¬ë¦¼
        # Case 3: ìì‹ì´ 2ê°œ -> ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì˜ ìµœì†Œê°’(Successor)ì„ ì°¾ì•„ ë‚´ ìœ„ì¹˜ë¡œ ì˜®ê¸°ê³ , Successorë¥¼ ì‚­ì œ
        pass
```

### 3. ìµœì†Œ í™ (Min Heap) êµ¬í˜„
```python
class MinHeap:
    def __init__(self):
        self.heap = []

    def push(self, val):
        self.heap.append(val) # ë§¨ ëì— ì¶”ê°€
        self._sift_up(len(self.heap) - 1) # ìœ„ë¡œ ì˜¬ë¦¬ê¸°

    def pop(self):
        if not self.heap:
            raise IndexError("pop from empty heap")
        if len(self.heap) == 1:
            return self.heap.pop()
        
        root_val = self.heap[0]
        self.heap[0] = self.heap.pop() # ë§ˆì§€ë§‰ ìš”ì†Œë¥¼ ë£¨íŠ¸ë¡œ ì´ë™
        self._sift_down(0) # ì•„ë˜ë¡œ ë‚´ë¦¬ê¸°
        return root_val

    def _sift_up(self, idx):
        parent = (idx - 1) // 2
        # ë£¨íŠ¸ê°€ ì•„ë‹ˆê³ , ë¶€ëª¨ë³´ë‹¤ ë‚´ê°€ ë” ì‘ìœ¼ë©´ êµí™˜ (ìµœì†Œ í™ ì„±ì§ˆ)
        if idx > 0 and self.heap[idx] < self.heap[parent]:
            self.heap[idx], self.heap[parent] = self.heap[parent], self.heap[idx]
            self._sift_up(parent)

    def _sift_down(self, idx):
        # êµ¬í˜„ ê³¼ì œ: ìì‹ ì¤‘ ë” ì‘ì€ ê°’ê³¼ êµí™˜í•˜ë©° ë‚´ë ¤ê°€ê¸°
        # 1. ì™¼ìª½ ìì‹ í™•ì¸
        # 2. ì˜¤ë¥¸ìª½ ìì‹ í™•ì¸
        # 3. ë‘˜ ì¤‘ ë” ì‘ì€ ìì‹ê³¼ ë¹„êµí•˜ì—¬, ë‚´ê°€ ë” í¬ë©´ êµí™˜
        pass
```

## âœ… ì´ë²ˆ ì£¼ ê³¼ì œ
1. `inorder`, `postorder` ìˆœíšŒ í•¨ìˆ˜ ì™„ì„±í•˜ê¸°
2. `BST`ì˜ `search` ë©”ì„œë“œ ì™„ì„±í•˜ê¸°
3. `MinHeap`ì˜ `_sift_down` ë©”ì„œë“œ ì™„ì„±í•˜ê¸°
4. (ì‹¬í™”) `BST`ì˜ `delete` ë©”ì„œë“œ êµ¬í˜„í•˜ê¸° (ê°€ì¥ ê¹Œë‹¤ë¡œìš´ ë¶€ë¶„ì…ë‹ˆë‹¤!)
